{"name":"ZIYAN137","slug":"ZIYAN137","count":4,"postlist":[{"title":"char-encoding","slug":"char-encoding","date":"2025-06-01T15:36:50.000Z","updated":"2025-06-01T15:44:15.269Z","comments":true,"path":"api/articles/char-encoding.json","excerpt":"<h1 id=\"前导\"><a href=\"#前导\" class=\"headerlink\" title=\"前导\"></a>前导</h1><p>一些关于字符编码的知识</p>","keywords":null,"cover":"/../Asset/char-encoding/image.png","content":null,"text":"前导一些关于字符编码的知识字符集众所周知，计算机不能直接存储字符，而是用数字来代替。字符集为每个字符指定一个数字。ASCII其中最为著名就是ASCII。它为英文字母、阿拉伯数组、标点符号等 128 个字符，每个都用一个 0 到 127 范围内的数字对应。如果你想要表示一个字符，就","raw":null,"photos":[],"categories":[],"tags":[{"name":"ZIYAN137","slug":"ZIYAN137","count":4,"path":"api/tags/ZIYAN137.json"}]},{"title":"cpp-return-value-optimization","slug":"cpp-return-value-optimization","date":"2025-05-28T08:23:00.000Z","updated":"2025-06-01T15:44:15.269Z","comments":true,"path":"api/articles/cpp-return-value-optimization.json","excerpt":"<p>返回值优化是C++中的一种编译优化技术，它允许编译器将函数返回的对象直接构造到它们本来要存储的变量空间中而不产生临时对象。这样子可以减少复制构造和移动构造的次数，提升性能。</p>","keywords":null,"cover":null,"content":null,"text":"返回值优化是C++中的一种编译优化技术，它允许编译器将函数返回的对象直接构造到它们本来要存储的变量空间中而不产生临时对象。这样子可以减少复制构造和移动构造的次数，提升性能。严格来说返回值优化分为RVO（Return Value Optimization）和 NRVO（Named ","raw":null,"photos":[],"categories":[],"tags":[{"name":"ZIYAN137","slug":"ZIYAN137","count":4,"path":"api/tags/ZIYAN137.json"},{"name":"cpp","slug":"cpp","count":3,"path":"api/tags/cpp.json"}]},{"title":"cpp-value-categories","slug":"cpp-value-categories","date":"2025-05-18T05:02:45.000Z","updated":"2025-06-01T15:44:15.269Z","comments":true,"path":"api/articles/cpp-value-categories.json","excerpt":"<p>在C++中所谓的左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。</p>\n<p>而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。</p>","keywords":null,"cover":"/../Asset/cpp-value-categories/image.png","content":null,"text":"在C++中所谓的左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。基于这一特征，我们可以用取地址符&amp;来判断左值和右值，能取到内","raw":null,"photos":[],"categories":[],"tags":[{"name":"ZIYAN137","slug":"ZIYAN137","count":4,"path":"api/tags/ZIYAN137.json"},{"name":"cpp","slug":"cpp","count":3,"path":"api/tags/cpp.json"}]},{"title":"rcore_camp_2025S_stage1&2","slug":"rcore-camp-2025S-stage1&2","date":"2025-04-30T09:03:26.000Z","updated":"2025-06-01T15:44:15.269Z","comments":true,"path":"api/articles/rcore-camp-2025S-stage1&2.json","excerpt":"<h1 id=\"前导\"><a href=\"#前导\" class=\"headerlink\" title=\"前导\"></a>前导</h1><p>本博客作为开源操作系统训练营2025S的1、2阶段学习记录，简单总结了在这两个阶段的学习和coding。留作纪念，也希望能够帮助到大家。</p>","keywords":null,"cover":null,"content":null,"text":"前导本博客作为开源操作系统训练营2025S的1、2阶段学习记录，简单总结了在这两个阶段的学习和coding。留作纪念，也希望能够帮助到大家。Stage1所有权系统在传统的语言中，要么使用GC来管理内存（如Java），要么让程序员自己管理内存（如C/C++）。<br>前者需要运行在","raw":null,"photos":[],"categories":[],"tags":[{"name":"ZIYAN137","slug":"ZIYAN137","count":4,"path":"api/tags/ZIYAN137.json"},{"name":"Rcore","slug":"Rcore","count":1,"path":"api/tags/Rcore.json"}]}]}