{"name":"Slice","slug":"Slice","count":1,"postlist":[{"title":"Rust中Slice类型的详解","slug":"zemu_first","date":"2025-04-28T12:18:12.000Z","updated":"2025-06-01T15:44:15.269Z","comments":true,"path":"api/articles/zemu_first.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Slice-概念\"><a href=\"#Slice-概念\" class=\"headerlink\" title=\"Slice 概念\"></a>Slice 概念</h1><p>Slice 允许你引用集合中的一部分连续的元素序列，而不需要拥有这些元素的所有权。<br>Slice 的长度（包含多少个元素）是在运行时确定的，而不是在编译时。<br>因此，<strong>Slice 类型本身</strong>（如 [T] 或 str）是 <strong>动态大小类型 (Dynamically Sized Type, DST)</strong>。<br>它本身不拥有数据，只是单纯地指某块连续内存。<br>我们不能直接创建 DST 类型的变量，只能通过其<strong>引用</strong>（如 &amp;[T] 或 &amp;str）来使用它们。</p>\n<p>常用对 slice 的引用有两种：</p>\n<h2 id=\"T-切片引用\"><a href=\"#T-切片引用\" class=\"headerlink\" title=\"&[T] 切片引用\"></a>&amp;[T] 切片引用</h2><p>这是对类型 T 的数组或 Vec<t>（或实现了 Deref&lt;Target=[T]&gt; 的其他类型）的一部分的引用。<br>&amp;[T] 在内部实际上是一个 <strong>胖指针 (fat pointer)</strong>，包含两个信息：</t></p>\n<ul>\n<li>一个指向 Slice 第一个元素的指针</li>\n<li>Slice 的长度，即它包含多少个元素</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：从数组创建切片</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">arr</span>: [<span class=\"type\">i32</span>; <span class=\"number\">5</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_all</span>: &amp;[<span class=\"type\">i32</span>] = &amp;arr;         <span class=\"comment\">// 引用整个数组 [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_all_explicit</span>: &amp;[<span class=\"type\">i32</span>] = &amp;arr[..]; <span class=\"comment\">// 显式引用整个数组，效果同上</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 range 语法创建部分元素的切片</span></span><br><span class=\"line\"><span class=\"comment\">// range a..b 包含索引 a，但不包含索引 b</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_part</span>: &amp;[<span class=\"type\">i32</span>] = &amp;arr[<span class=\"number\">1</span>..<span class=\"number\">4</span>];   <span class=\"comment\">// 引用索引 1 到 3 (不包括 4) 的元素 [2, 3, 4]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_from</span>: &amp;[<span class=\"type\">i32</span>] = &amp;arr[<span class=\"number\">2</span>..];    <span class=\"comment\">// 引用索引 2 到末尾的元素 [3, 4, 5]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_to</span>: &amp;[<span class=\"type\">i32</span>] = &amp;arr[..<span class=\"number\">3</span>];     <span class=\"comment\">// 引用从开头到索引 2 (不包括 3) 的元素 [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"arr: {:?}\"</span>, arr); <span class=\"comment\">// 使用标准引号 \"</span></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_all: {:?}\"</span>, slice_all);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_part: {:?}\"</span>, slice_part);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_from: {:?}\"</span>, slice_from);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_to: {:?}\"</span>, slice_to);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：从 Vec 创建切片</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">vec</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">i32</span>&gt; = <span class=\"built_in\">vec!</span>[<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>]; <span class=\"comment\">// 修正：明确 Vec 类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_vec</span>: &amp;[<span class=\"type\">i32</span>] = &amp;vec[..];        <span class=\"comment\">// 引用整个 Vec 的数据部分 [10, 20, 30, 40]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_vec_part</span>: &amp;[<span class=\"type\">i32</span>] = &amp;vec[<span class=\"number\">1</span>..<span class=\"number\">3</span>]; <span class=\"comment\">// 引用 Vec 中索引 1 到 2 的元素 [20, 30]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"vec: {:?}\"</span>, vec);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_vec: {:?}\"</span>, slice_vec);</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_vec_part: {:?}\"</span>, slice_vec_part);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例：可变切片引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">arr_mut</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">mut_slice</span>: &amp;<span class=\"keyword\">mut</span> [<span class=\"type\">i32</span>] = &amp;<span class=\"keyword\">mut</span> arr_mut[<span class=\"number\">1</span>..]; <span class=\"comment\">// 获取对索引 1 及之后元素的可变引用 [2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以通过可变切片修改原数组或 Vec 的数据</span></span><br><span class=\"line\">mut_slice[<span class=\"number\">0</span>] = <span class=\"number\">99</span>; <span class=\"comment\">// 修改切片中的第一个元素（对应原数组索引 1 的元素）</span></span><br><span class=\"line\"><span class=\"comment\">// mut_slice[1] = 100; // 修改切片中的第二个元素（对应原数组索引 2 的元素）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"Original arr_mut after modification: {:?}\"</span>, arr_mut); <span class=\"comment\">// 输出：Original arr_mut after modification: [1, 99, 3]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong> &amp;[T] 和 &amp;[T;N] 是两回事。<br>&amp;[T; N] 是单个指针，&amp;[T] 是胖指针（指针 + 长度）。<br>如果我们直接获取某数组的一个引用，则是 &amp;[T;N] 类型的，编译时可以确定长度。<br>当然你也可以把类型写成 &amp;[T] ，这属于数组引用隐式转换为切片引用（&amp;[T]）。<br>因为固定大小总是可以被视为一个动态大小，编译器可以轻松地构造出 (指针, 长度 N) 这个胖指针。<br>而对 slice 的引用则是 &amp;[T] ，不能写成 &amp;[T;N] ，因为 slice 是一个 DST 类型。<br>其长度在编译期不能确定，其引用不能隐式转回长度在编译期可以确定的数组引用。<br>如果你想强转回去，可以使用 try_into() 方法。<br>这个方法会在运行时检查切片的长度。如果长度正好是 N，它会返回 Ok(&amp;[T; N])；否则返回 Err。</p>\n<h2 id=\"str-字符串切片\"><a href=\"#str-字符串切片\" class=\"headerlink\" title=\"&str 字符串切片\"></a>&amp;str 字符串切片</h2><p>str 是 Rust 的原生字符串类型，代表一个有效的 UTF-8 字节序列，但它本身也是一个 DST。<br>因此，我们几乎总是通过它的引用形式 &amp;str 来使用它。<br>&amp;str 通常就被称为<strong>字符串切片</strong>。</p>\n<p>与 &amp;[T] 类似，&amp;str 在内部也是一个胖指针，包含：</p>\n<ul>\n<li>一个指向构成字符串的 UTF-8 字节序列的第一个字节的指针</li>\n<li>字符串切片的<strong>字节长度</strong></li>\n</ul>\n<p><strong>重要特性与约束:</strong></p>\n<ul>\n<li>Rust 的 String 和 &amp;str 都保证其内容始终是有效的 UTF-8 编码。</li>\n<li>对 String 或 &amp;str 进行切片操作时，索引是基于<strong>字节</strong>的。</li>\n<li>必须确保切片的起始和结束边界都落在有效的 UTF-8 <strong>字符边界</strong>上。<br>如果在某个字符的多字节表示的中间进行切割，程序会在运行时 panic（崩溃）。</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串字面量本身就是 &amp;'static str 类型 (一个具有静态生命周期的字符串切片)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">s_literal</span>: &amp;<span class=\"symbol\">'static</span> <span class=\"type\">str</span> = <span class=\"string\">\"Hello, Rust!\"</span>; <span class=\"comment\">// 使用标准引号 \" 和 '</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从 String 创建字符串切片</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">my_string</span>: <span class=\"type\">String</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">\"你好，世界\"</span>); <span class=\"comment\">// \"你好，世界\" 是 UTF-8 编码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用整个 String 的数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_str_all</span>: &amp;<span class=\"type\">str</span> = &amp;my_string;         <span class=\"comment\">// 隐式引用整个字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_str_all_explicit</span>: &amp;<span class=\"type\">str</span> = &amp;my_string[..]; <span class=\"comment\">// 显式引用整个字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用部分 String 数据</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：索引是基于 *字节* 的，并且必须落在字符边界上</span></span><br><span class=\"line\"><span class=\"comment\">// 在 UTF-8 中:</span></span><br><span class=\"line\"><span class=\"comment\">// '你' 占 3 字节 (0, 1, 2) // 使用标准单引号 '</span></span><br><span class=\"line\"><span class=\"comment\">// '好' 占 3 字节 (3, 4, 5)</span></span><br><span class=\"line\"><span class=\"comment\">// '，' 占 3 字节 (6, 7, 8)</span></span><br><span class=\"line\"><span class=\"comment\">// '世' 占 3 字节 (9, 10, 11)</span></span><br><span class=\"line\"><span class=\"comment\">// '界' 占 3 字节 (12, 13, 14)</span></span><br><span class=\"line\"><span class=\"comment\">// 总共 15 个字节</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合法的切片：边界都在字符之间</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_part_str</span>: &amp;<span class=\"type\">str</span> = &amp;my_string[<span class=\"number\">0</span>..<span class=\"number\">6</span>]; <span class=\"comment\">// 引用前两个字符 \"你好\" (字节 0 到 5)</span></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_part_str: {}\"</span>, slice_part_str); <span class=\"comment\">// 输出：slice_part_str: 你好</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_from_str</span>: &amp;<span class=\"type\">str</span> = &amp;my_string[<span class=\"number\">9</span>..]; <span class=\"comment\">// 引用从第 10 个字节（索引 9）开始到末尾 \"世界\"</span></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_from_str: {}\"</span>, slice_from_str); <span class=\"comment\">// 输出：slice_from_str: 世界</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">slice_to_str</span>: &amp;<span class=\"type\">str</span> = &amp;my_string[..<span class=\"number\">12</span>]; <span class=\"comment\">// 引用从开头到第 12 个字节（不包括索引 12）\"你好，世\"</span></span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"slice_to_str: {}\"</span>, slice_to_str); <span class=\"comment\">// 输出：slice_to_str: 你好，世</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非法的切片：边界落在了字符内部，会导致 panic</span></span><br><span class=\"line\"><span class=\"comment\">// let invalid_slice = &amp;my_string[0..1]; // 错误！字节 1 在 '你' 的中间</span></span><br><span class=\"line\"><span class=\"comment\">// let invalid_slice2 = &amp;my_string[..8]; // 错误！字节 8 在 '，' 的中间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Rust 提供方法检查边界是否合法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> my_string.<span class=\"title function_ invoke__\">is_char_boundary</span>(<span class=\"number\">1</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 不会执行，因为 1 不是字符边界</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">_slice</span> = &amp;my_string[..<span class=\"number\">1</span>];</span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"Index 1 is not a valid char boundary for '{}'\"</span>, my_string); <span class=\"comment\">// 使用标准单引号 '</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 &amp;mut str (可变字符串切片) 比较少见，并且需要格外小心</span></span><br><span class=\"line\"><span class=\"comment\">// String 没有提供安全的、公开的获取 &amp;mut str 的方法，因为任意修改字节可能破坏 UTF-8 有效性。</span></span><br><span class=\"line\"><span class=\"comment\">// 通常通过操作底层的 &amp;mut [u8] (可变字节切片) 并确保结果是有效 UTF-8，</span></span><br><span class=\"line\"><span class=\"comment\">// 或者使用一些知道自己在做什么的 unsafe 代码（如 String::as_mut_str）。</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// let mut_str_slice: &amp;mut str = s.as_mut_str(); // as_mut_str 是 unsafe 的</span></span><br><span class=\"line\"><span class=\"comment\">// 安全地修改 &amp;mut str 的例子（如使用 &amp;str 的方法）</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    <span class=\"comment\">// 获取可变字节切片是安全的，但需要确保后续操作维持 UTF-8 有效性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">mut_bytes</span>: &amp;<span class=\"keyword\">mut</span> [<span class=\"type\">u8</span>] = <span class=\"keyword\">unsafe</span> { s.<span class=\"title function_ invoke__\">as_bytes_mut</span>() }; <span class=\"comment\">// 注意 unsafe</span></span><br><span class=\"line\">    <span class=\"comment\">// 在字节层面修改，但要保证结果仍是有效 UTF-8</span></span><br><span class=\"line\">    mut_bytes.<span class=\"title function_ invoke__\">make_ascii_uppercase</span>(); <span class=\"comment\">// 这个方法保证了 ASCII 范围内的 UTF-8 有效性</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"Modified string: {}\"</span>, s); <span class=\"comment\">// 输出：Modified string: HELLO</span></span><br></pre></td></tr></table></figure>","text":"Slice 概念Slice 允许你引用集合中的一部分连续的元素序列，而不需要拥有这些元素的所有权。<br>Slice 的长度（包含多少个元素）是在运行时确定的，而不是在编译时。<br>因此，Slice 类型本身（如 [T] 或 str）是 动态大小类型 (Dynamically ","raw":null,"photos":[],"categories":[],"tags":[{"name":"zemu","slug":"zemu","count":3,"path":"api/tags/zemu.json"},{"name":"Rust","slug":"Rust","count":3,"path":"api/tags/Rust.json"},{"name":"Slice","slug":"Slice","count":1,"path":"api/tags/Slice.json"}]}]}