{"title":"cpp-value-categories","slug":"cpp-value-categories","date":"2025-05-18T05:02:45.000Z","updated":"2025-06-01T15:44:15.269Z","comments":true,"path":"api/articles/cpp-value-categories.json","photos":[],"excerpt":"在C++中所谓的左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。","covers":["/../Asset/cpp-value-categories/image.png"],"content":"<p>在C++中所谓的左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。</p>\n<p>而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。</p>\n<span id=\"more\"></span>\n\n<p>基于这一特征，我们可以用取地址符&amp;来判断左值和右值，能取到内存地址的值为左值，否则为右值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_val</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_val</span><span class=\"params\">(<span class=\"type\">int</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{ </span><br><span class=\"line\">  x = val;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">  x++;</span><br><span class=\"line\">  ++x;</span><br><span class=\"line\">  <span class=\"type\">int</span> y = <span class=\"built_in\">get_val</span>();</span><br><span class=\"line\">  <span class=\"built_in\">set_val</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>x++和++x虽然都是自增操作，但是却分为不同的左右值。其中x++是右值，因为在后置++操作中编译器首先会生成一份x值的临时复制，然后才对x递增，最后返回临时复制内容。而++x则不同，它是直接对x递增后马上返回其自身，所以++x是一个左值。</p>\n<p>get_val函数返回了一个全局变量x，虽然很明显变量x是一个左值，但是它经过函数返回以后变成了一个右值。原因和x++类似，在函数返回的时候编译器并不会返回x本身， 而是返回x的临时复制。</p>\n<p>set_val函数，该函数接受一个参数并且将参数的值赋值到x中。在main函数中set_val(6);实参6是一个右值，但是进入函数之后形参 val却变成了一个左值，我们可以对val使用取地址符，并且不会引起任何问题</p>\n<p>最后强调的是，字面量通常是右值，但是字符串字面量不是。编译器会将字符串字面量存储到程序的数据段中，程序加载的时候也会 为其开辟内存空间，所以我们可以使用取地址符&amp;来获取字符串字面量 的内存地址。 </p>\n<h1 id=\"左值引用\"><a href=\"#左值引用\" class=\"headerlink\" title=\"左值引用\"></a>左值引用</h1><p>左值引用使得C++在一定程度上脱离了危险的指针。当我们需要将一个对象作为参数传递给函数的时候，往往会使用左值引用，因为这样可以免去创建临时对象的操作。</p>\n<p>此外，常量左值引用还可以引用右值，延长右值的生命周期。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">X</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">X</span>() {}</span><br><span class=\"line\">    <span class=\"built_in\">X</span>(<span class=\"type\">const</span> X &amp;) {}</span><br><span class=\"line\">    X &amp;<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> X &amp;) { <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\">X <span class=\"title\">make_x</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">X</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    X x1;</span><br><span class=\"line\">    <span class=\"function\">X <span class=\"title\">x2</span><span class=\"params\">(x1)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">X <span class=\"title\">x3</span><span class=\"params\">(make_x())</span></span>;</span><br><span class=\"line\">    x3 = <span class=\"built_in\">make_x</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>常量左值引用可以绑定右值是一条非常棒的特性，但是因为他是常量，所以无法对他进行修改。因此，我们需要另一特性——右值引用</p>\n<h1 id=\"右值引用及其带来的性能优化\"><a href=\"#右值引用及其带来的性能优化\" class=\"headerlink\" title=\"右值引用及其带来的性能优化\"></a>右值引用及其带来的性能优化</h1><p>右值引用，顾名思义就是一种只能引用右值的方法，可以对比左值引用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">0</span>; </span><br><span class=\"line\"><span class=\"type\">int</span> &amp;j = i; <span class=\"comment\">// 左值引用 </span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;&amp;k = <span class=\"number\">11</span>; <span class=\"comment\">// 右值引用</span></span><br></pre></td></tr></table></figure>\n\n<p>右值引用的特点之一是可以延长右值的生命周期，就像这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">X</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">X</span>() { std::cout &lt;&lt; <span class=\"string\">\"X ctor\"</span> &lt;&lt; std::endl; }</span><br><span class=\"line\">    <span class=\"built_in\">X</span>(<span class=\"type\">const</span> X &amp;x) { std::cout &lt;&lt; <span class=\"string\">\"X copy ctor\"</span> &lt;&lt; std::endl; }</span><br><span class=\"line\">    ~<span class=\"built_in\">X</span>() { std::cout &lt;&lt; <span class=\"string\">\"X dtor\"</span> &lt;&lt; std::endl; }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>{ std::cout &lt;&lt; <span class=\"string\">\"show X\"</span> &lt;&lt; std::endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\">X <span class=\"title\">make_x</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    X x1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x1;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    X &amp;&amp;x2 = <span class=\"built_in\">make_x</span>();</span><br><span class=\"line\">    x<span class=\"number\">2.</span><span class=\"built_in\">show</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果将X &amp;&amp;x2 = make_x() 这句代码替换为X x2 = make_x()会发生三次构造。</p>\n<ol>\n<li><p>make_x函数中x1会默认构造</p>\n</li>\n<li><p>return x1会使用复制构造产生临时对象</p>\n</li>\n<li><p>X x2 = make_x() 会使用复制构造将临时对象复制到x2</p>\n</li>\n</ol>\n<p>而使用右值引用就只进行了两次构造。</p>\n<ol>\n<li><p>make_x函数中x1的默认构造</p>\n</li>\n<li><p>第二次是return x1引发的复制构造。</p>\n</li>\n</ol>\n<p>不同的是，由于x2是一个右值引用，引用的对象是函数make_x返回的临时对象，因此该临时对象的生命周期得到延长，所以我们可以 在X &amp;&amp;x2 = make_x()语句结束后继续调用show函数而不会发生任何问题。</p>\n<p>但是右值引用的最终目的并非延长临时对象的生命周期，而是减少复制的次数，提升程序性能。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BigMemoryPool</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> PoolSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">    <span class=\"built_in\">BigMemoryPool</span>() : <span class=\"built_in\">pool_</span>(<span class=\"keyword\">new</span> <span class=\"type\">char</span>[PoolSize]) {}</span><br><span class=\"line\">    ~<span class=\"built_in\">BigMemoryPool</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool_ != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">delete</span>[] pool_;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">BigMemoryPool</span>(<span class=\"type\">const</span> BigMemoryPool &amp;other) : <span class=\"built_in\">pool_</span>(<span class=\"keyword\">new</span> <span class=\"type\">char</span>[PoolSize])</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"copy big memory pool.\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(pool_, other.pool_, PoolSize);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span> *pool_;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\">BigMemoryPool <span class=\"title\">get_pool</span><span class=\"params\">(<span class=\"type\">const</span> BigMemoryPool &amp;pool)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pool;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\">BigMemoryPool <span class=\"title\">make_pool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    BigMemoryPool pool;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get_pool</span>(pool);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    BigMemoryPool my_pool = <span class=\"built_in\">make_pool</span>();</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>这段代码虽然是正确的，但是调用了3次复制构造函数。每一次复制都需要4KB的数据，开销较大。如果数据体积更大，对程序带来的影响也更大。</p>\n<p>第2、3次都是影响性能的主要原因</p>\n<blockquote>\n<p>因为有临时对象，临时对象本身只是复制。</p>\n</blockquote>\n<p>因此，如果能直接转移其内存，就能消除复制的开销。于是我们可以使用移动语义来进行内存的转移。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BigMemoryPool</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> PoolSize = <span class=\"number\">4096</span>;</span><br><span class=\"line\">    <span class=\"built_in\">BigMemoryPool</span>() : <span class=\"built_in\">pool_</span>(<span class=\"keyword\">new</span> <span class=\"type\">char</span>[PoolSize]) {}</span><br><span class=\"line\">    ~<span class=\"built_in\">BigMemoryPool</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool_ != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">delete</span>[] pool_;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 右值引用类型</span></span><br><span class=\"line\">    <span class=\"built_in\">BigMemoryPool</span>(BigMemoryPool &amp;&amp;other)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"move big memory pool.\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        pool_ = other.pool_;</span><br><span class=\"line\">        other.pool_ = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">BigMemoryPool</span>(<span class=\"type\">const</span> BigMemoryPool &amp;other) : <span class=\"built_in\">pool_</span>(<span class=\"keyword\">new</span> <span class=\"type\">char</span>[PoolSize])</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"copy big memory pool.\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(pool_, other.pool_, PoolSize);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span> *pool_;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"值类别\"><a href=\"#值类别\" class=\"headerlink\" title=\"值类别\"></a>值类别</h1><p>C++11标准中新引入的概念，将表达式分为3个类别是左值（lvalue）、纯右值（prvalue）和将亡值（xvalue）</p>\n<p><img src=\"/../Asset/cpp-value-categories/image.png\"></p>\n<p>左值是具名对象，可以被取地址、有持久状态的对象。</p>\n<p>纯右值是没有身份的临时值，通常是表达式计算的结果，没有对应的内存地址。</p>\n<p>将亡值则是表示一个有身份但其资源可以被重复使用或移动的对象。</p>\n<p>将亡值的产生一般有两种</p>\n<ol>\n<li><p><code>static_cast</code>来换将泛左值转换为该类型的右值引用</p>\n</li>\n<li><p>C++17引入的，纯右值转换到临时对象，这个临时对象就是将亡值</p>\n</li>\n</ol>\n<h1 id=\"左值转为右值\"><a href=\"#左值转为右值\" class=\"headerlink\" title=\"左值转为右值\"></a>左值转为右值</h1><p>上文提到，我们可以把左值转换为将亡值来将其变为一个右值，从而进行右值引用。</p>\n<p>但是建议通过<code>std::move</code>进行转换，而非<code>static_cast</code>，这样子可读性更好（虽然<code>std::move</code>内部也是用static_cast做类型转换）。一般用于右值转换为左值之后，需要重新转换为右值的情况</p>\n<h1 id=\"万能引用与引用折叠\"><a href=\"#万能引用与引用折叠\" class=\"headerlink\" title=\"万能引用与引用折叠\"></a>万能引用与引用折叠</h1><p>常量左值引用既可以引用左值又可以引用右值，是一个几乎万能的引用，但是因为它是个常量，所以使用起来很受限。</p>\n<p>真正的万能引用可以这么写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bar</span><span class=\"params\">(T &amp;&amp;t)</span> </span>{}    <span class=\"comment\">// t为万能引用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> &amp;&amp;y = <span class=\"built_in\">get_val</span>(); <span class=\"comment\">// y为万能引用</span></span><br></pre></td></tr></table></figure>\n\n<p>不难发现，所谓的万能引用就是因为发送了类型推导。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值，则会推导出右值引用，不过无论如何都会是一个引用类型。</p>\n<p>而之所以万能引用如此灵活，就是因为C++11中添加了一套引用叠加推导的规则——引用折叠。</p>\n<table>\n<thead>\n<tr>\n<th>T模板型</th>\n<th>T实际类型</th>\n<th>最终类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>T&amp;</td>\n<td>R</td>\n<td>R&amp;</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>R&amp;</td>\n<td>R&amp;</td>\n</tr>\n<tr>\n<td>T&amp;</td>\n<td>R&amp;&amp;</td>\n<td>R&amp;</td>\n</tr>\n<tr>\n<td>T&amp;&amp;</td>\n<td>R</td>\n<td>R&amp;&amp;</td>\n</tr>\n<tr>\n<td>T&amp;&amp;</td>\n<td>R&amp;</td>\n<td>R&amp;</td>\n</tr>\n<tr>\n<td>T&amp;&amp;</td>\n<td>R&amp;&amp;</td>\n<td>R&amp;&amp;</td>\n</tr>\n</tbody></table>\n<p>此外，万能引用的形式必须是T&amp;&amp;或者auto&amp;&amp;，也就是说它们必须在初始化的时候被直接推导出来，如果在推导中出现中间过程，则不是一个万能引用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(std::vector&lt;T&gt; &amp;&amp;t)</span> </span>{}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; v{<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>};</span><br><span class=\"line\">    <span class=\"built_in\">foo</span>(v); <span class=\"comment\">// 编译错误</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>因为foo的形参类型是<code>std::vector&lt;T&gt;&amp;&amp;</code>而不是<code>T&amp;&amp;</code>，所以编译器无法将其看作一个万能 引用处理。 </p>\n<h1 id=\"完美转发\"><a href=\"#完美转发\" class=\"headerlink\" title=\"完美转发\"></a>完美转发</h1><p>万能引用最典型的用途被称为完美转发。</p>\n<p>现在先来看看传统的转发：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show_type</span><span class=\"params\">(T t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">typeid</span>(t).<span class=\"built_in\">name</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">normal_forwarding</span><span class=\"params\">(T t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">show_type</span>(t);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    std::string s = <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">normal_forwarding</span>(s);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>它虽然能完成字符串的转发任务，但是效率低下。所以我们要使用引用进行转发。但是单单使用左值引用不能完美符合我们的需求。因此，我们可以使用万能转发。无论传递的是左值还是右值都可以被转发，而且不会发生多余的临时复制。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show_type</span><span class=\"params\">(T t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">typeid</span>(t).<span class=\"built_in\">name</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">perfect_forwarding</span><span class=\"params\">(T &amp;&amp;t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">show_type</span>(<span class=\"built_in\">static_cast</span>&lt;T &amp;&amp;&gt;(t));</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">get_string</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"hi world\"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    std::string s = <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">perfect_forwarding</span>(s);</span><br><span class=\"line\">    <span class=\"built_in\">perfect_forwarding</span>(<span class=\"built_in\">get_string</span>());</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>和移动语义的情况一样，显式使用static_cast类型转换进行转发不是一个便捷的方法。在C++11的标准库中提供了一个std::forward函数模板，在函数内部也是使用static_cast进行类型转换，只不过使用std::forward转发语义会表达得更加清晰。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">perfect_forwarding</span><span class=\"params\">(T &amp;&amp;t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"built_in\">show_type</span>(std::forward&lt;T&gt;(t));</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>","categories":[],"tags":[{"name":"ZIYAN137","slug":"ZIYAN137","count":4,"path":"api/tags/ZIYAN137.json"},{"name":"cpp","slug":"cpp","count":3,"path":"api/tags/cpp.json"}]}