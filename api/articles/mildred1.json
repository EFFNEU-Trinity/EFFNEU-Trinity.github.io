{"title":"cpp智能指针讨论","slug":"mildred1","date":"2025-04-29T07:18:00.000Z","updated":"2025-06-01T15:44:15.269Z","comments":true,"path":"api/articles/mildred1.json","photos":[],"excerpt":null,"covers":["/Asset/image.png"],"content":"<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>智能指针秉承 RAII 的思想，所以管理的资源应是<strong>获取即初始化</strong>的，动态管理的资源（即 new 在堆上的资源）。</p>\n<h4 id=\"优先使用-make-系列函数而非-new-来创建智能指针\"><a href=\"#优先使用-make-系列函数而非-new-来创建智能指针\" class=\"headerlink\" title=\"优先使用 make 系列函数而非 new 来创建智能指针\"></a>优先使用 make 系列函数而非 new 来创建智能指针</h4><p>make 系列有三个函数：make_shared(),make_unique(),allocate_shared()。</p>\n<p>allocate_shared()的第一个实参为动态分配内存的分配器对象。</p>\n<p>使用 make 系列函数可以避免冗余代码，且保证内存安全：</p>\n<p>但在需要自定义删除器的时候，应该使用构造函数（make 函数不允许传入自定义删除器）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 直接使用 new 和 shared_ptr 构造函数</span></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;MyClass&gt; <span class=\"title\">sp</span><span class=\"params\">(<span class=\"keyword\">new</span> MyClass)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 其他可能抛出异常的代码...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">如果在sp构造完毕之前，MyClass内存分配完毕之后（二者的发生顺序由编译器控制，中间可能执行其他代码）发生了异常，就会导致MyClass新对象的内存无法被释放，造成内存泄漏。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 使用 make_shared</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> sp = std::<span class=\"built_in\">make_shared</span>&lt;MyClass&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 其他可能抛出异常的代码...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">make_shared</span>()将对象创建和控制块分配绑定，二者会一次性完成，从而有效地保证了内存的安全。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">make_unique</span>()等同理。</span><br><span class=\"line\"></span><br><span class=\"line\">从内存空间的角度来看，前者会将对象的内存和控制块的内存分配到不同地址，进行了两次分配，效率较低。</span><br><span class=\"line\">而后者则将对象和控制块分配到一块连续的内存上，提升了效率。</span><br><span class=\"line\"></span><br><span class=\"line\">需要注意，析构时，如果控制块对应的内存不析构，连续分配的对象内存也无法析构。（在引用计数为<span class=\"number\">0</span>而弱计数不为<span class=\"number\">0</span>时会发生）</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-unique-ptr：独占所有权\"><a href=\"#std-unique-ptr：独占所有权\" class=\"headerlink\" title=\"std::unique_ptr：独占所有权\"></a>std::unique_ptr：独占所有权</h4><p>std::unique_ptr 删除了拷贝构造函数和拷贝赋值运算符（= delete），不允许通过这些方式来转移数据的所有权。</p>\n<p>而应该使用 <code>std::move</code> 。</p>\n<h5 id=\"创建对象指针或数组指针\"><a href=\"#创建对象指针或数组指针\" class=\"headerlink\" title=\"创建对象指针或数组指针\"></a>创建对象指针或数组指针</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> p1 = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"comment\">//不提供[]运算符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> p2 = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">int</span>[]&gt;(<span class=\"number\">5</span>); <span class=\"comment\">//（只允许给出一个参数表示容器大小）</span></span><br><span class=\"line\"><span class=\"comment\">//不提供*或-&gt;运算符</span></span><br><span class=\"line\"><span class=\"comment\">//不推荐使用</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"跨指针类型转换\"><a href=\"#跨指针类型转换\" class=\"headerlink\" title=\"跨指针类型转换\"></a>跨指针类型转换</h5><p>支持从 unique_ptr 到 shared_ptr 的隐式转换，反之则不支持。</p>\n<p>除非手动将引用计数为 1 的 shared_ptr 的资源转移给 unique_ptr。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; u = std::<span class=\"built_in\">make_unique</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; s = std::<span class=\"built_in\">move</span>(u);  <span class=\"comment\">// 所有权转移</span></span><br><span class=\"line\"><span class=\"comment\">// 此时 u == nullptr</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::shared_ptr&lt;<span class=\"type\">int</span>&gt; s = std::<span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"comment\">// std::unique_ptr&lt;int&gt; u = s;  // 编译错误</span></span><br><span class=\"line\"><span class=\"comment\">// 唯一方式：如果引用计数为1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(s.<span class=\"built_in\">use_count</span>() == <span class=\"number\">1</span>) {</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">u</span><span class=\"params\">(s.get())</span></span>;</span><br><span class=\"line\">    s.<span class=\"built_in\">reset</span>();  <span class=\"comment\">// 必须手动释放所有权</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除器\"><a href=\"#删除器\" class=\"headerlink\" title=\"删除器\"></a>删除器</h5><p>与 shared_ptr 相比，unique_ptr 的删除器本身作为指针对象的一部分，在使用构造函数传入删除器函数时，应该在模板参数中也声明删除器的类型。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> up_del1 = [](<span class=\"type\">int</span> * p){</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"up1 deleted.\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>, <span class=\"title\">decltype</span><span class=\"params\">(up_del1)</span>&gt; <span class=\"title\">up1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">42</span>), up_del1)</span></span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>unique_ptr 通过删除器以工厂模式对指针所指内容进行析构，支持复杂的资源管理，使所有析构操作由智能指针自动完成。</p>\n<h4 id=\"std-shared-ptr：分享所有权\"><a href=\"#std-shared-ptr：分享所有权\" class=\"headerlink\" title=\"std::shared_ptr：分享所有权\"></a>std::shared_ptr：分享所有权</h4><p>可以有多个指针共享一个数据，每创建一个指针，引用计数加一，每析构一个指针，引用计数减一。</p>\n<p>shared_ptr 的大小是裸指针的两倍，这是由于 shared_ptr 既包含了一个指向资源的裸指针，也包含了一个指向引用计数所在控制块的裸指针。</p>\n<p>引用计数的递增或递减必须是原子操作，读写效率比较低。</p>\n<p>与复制语义相比，移动语义对 shared_ptr 更有效率，因为引用计数不会发生变化。</p>\n<h5 id=\"shared-ptr-初始化与内存\"><a href=\"#shared-ptr-初始化与内存\" class=\"headerlink\" title=\"shared_ptr 初始化与内存\"></a>shared_ptr 初始化与内存</h5><p>如果使用 make_shared()对 shared_ptr 进行初始化，就不能自定义删除器，编译器会将对象和控制块绑定到连续的内存上。</p>\n<p>要使用自定义的删除器，应该使用 shared_ptr()的构造函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：管理文件指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">file_deleter</span><span class=\"params\">(FILE* f)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f) <span class=\"built_in\">fclose</span>(f);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    FILE* raw_fp = <span class=\"built_in\">fopen</span>(<span class=\"string\">\"data.txt\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//auto sp_fp = make_shared(raw_fp);</span></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;FILE&gt; <span class=\"title\">sp_fp</span><span class=\"params\">(raw_fp, file_deleter)</span></span>; <span class=\"comment\">//使用构造函数传递自定义删除器</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"enable-shared-from-this\"><a href=\"#enable-shared-from-this\" class=\"headerlink\" title=\"enable_shared_from_this\"></a>enable_shared_from_this</h5><p>enable_shared_from_this 是一个辅助 shared_ptr 使用的<strong>基类模板</strong>。</p>\n<p>使 this 裸指针能够安全地转换为 shared_ptr，避免以下危险操作：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">BadExample</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::shared_ptr&lt;BadExample&gt; get_shared() {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::shared_ptr&lt;BadExample&gt;(<span class=\"keyword\">this</span>); <span class=\"comment\">// 导致多个控制块</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">GoodExample</span> : <span class=\"symbol\">public</span> <span class=\"symbol\">std::<span class=\"symbol\">enable_shared_from_this</span></span>&lt;<span class=\"symbol\">GoodExample</span>&gt; {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">void</span> process() {</span><br><span class=\"line\">        <span class=\"comment\">//前提：已经有shared_ptr控制有效的控制块</span></span><br><span class=\"line\">        <span class=\"built_in\">auto</span> self = shared_from_this(); <span class=\"comment\">// 使用指定函数安全获取</span></span><br><span class=\"line\">        <span class=\"comment\">// 传递到异步回调等场景</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"控制块\"><a href=\"#控制块\" class=\"headerlink\" title=\"控制块\"></a>控制块</h5><p>与 unique_ptr 将删除器连续存储在指针对象中不同，shared_ptr 的删除器会存储在控制块中。</p>\n<p><img src=\"/Asset/image.png\"></p>\n<p>std::make_shared()总是创建一个控制块。</p>\n<p>从 unique_ptr 向 shared_ptr 转换总是会创建一个控制块。</p>\n<p>shared_ptr 的构造函数调用裸指针时，总是创建一个控制块。</p>\n<p>控制块附属于对象指针，所以使用同一裸指针多次构造 shared_ptr 会导致多重控制块，<strong>多重的控制块意味着多重的引用计数</strong>，将引发重复析构等问题。</p>\n<p>不允许也不应该使用 shared_ptr 指向数组。</p>\n<p>（图中的弱计数指的就是 weak_ptr 的引用计数）。</p>\n<h4 id=\"std-weak-ptr\"><a href=\"#std-weak-ptr\" class=\"headerlink\" title=\"std::weak_ptr\"></a>std::weak_ptr</h4><p>std::weak_ptr 指向 shared_ptr 管理的对象，但不会增加引用计数。</p>\n<p>可以从 shared_ptr 初始化一个 weak_ptr。</p>\n<p>使用.lock()将其转换为 shared_ptr 则可以临时访问对象。</p>\n<p>用于<strong>仅检测指针是否空悬</strong>，或<strong>类间循环引用</strong>的问题。</p>\n<p>无法解引用来获取 weak_ptr 中的内容，使用者只能通过.expired()观测到 weak_ptr 是否还指向有效内容。</p>\n<p>如果想要获取，就使用.lock()。</p>\n<p>weak_ptr 的大小与 shared_ptr 完全一致，它不会影响 shared_ptr 的引用计数，但拥有控制块中的另一个引用计数（即弱计数）。</p>\n","categories":[],"tags":[{"name":"cpp","slug":"cpp","count":3,"path":"api/tags/cpp.json"},{"name":"mildred","slug":"mildred","count":1,"path":"api/tags/mildred.json"},{"name":"智能指针","slug":"智能指针","count":2,"path":"api/tags/智能指针.json"}]}